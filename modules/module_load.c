/*
*   CHDK-FLAT Module System.  
*
*   (c)2011 Sergey Taranenko aka tsvstar
*
*   This is main file of module processing system. Module load/unload/service functions
*/

#include "camera_info.h"
#include "stdlib.h"
#include "conf.h"
#include "console.h"
#include "clock.h"
#include "cache.h"
#include "lang.h"
#include "gui_mbox.h"
#include "gui_lang.h"

#include "simple_module.h"
#include "module_load.h"
#include "module_exportlist.h"
#include "module_hash.h"

//-----------------------------------------------

// Symbol hash table for resolving exported symbol references
// see autogenerated file modules/module_hashlist.c
extern sym_hash symbol_hash_table[];

//-----------------------------------------------

// array of loaded modules (hdr == NULL -> slot is empty)
static module_entry modules[MAX_NUM_LOADED_MODULES];

//-----------------------------------------------

#define BUFFER_FOR_READ_SIZE    4096
#define MODULES_PATH            "A/CHDK/MODULES/"       // Module folder, module files are only loaded from here

// Generate a unique hash of the full module path
// Can't use lang_strhash31 as we want case-insensitive hashes here
// (File browser passes upper case names, modules names in modules.c are lower case
static unsigned int hash_module_name(char *str)
{
    unsigned int hash = 5381;
    int c;

    // djb2 hash algorithm (Dan Bernstein - http://cr.yp.to/djb.html)
    while ((c = *str++) != 0)
        hash = ((hash << 5) + hash) ^ toupper(c); /* hash * 33 xor c */

    return hash;
}

// Get full path of module file and hash of path
// If path specified in name, just copy it, otherwise prepend MODULES_PATH
// No validation on size of path variable - make sure you pass a buffer with enough space
// Returns hash value of path for comparison to loaded modules
static unsigned int get_module_path(char *path, const char *name)
{
    // Check if full path supplied?
    if ((tolower(name[0]) != 'a') || (name[1] != '/'))
        strcpy(path, MODULES_PATH);
    else
        path[0] = 0;
    // Add supplied name to path
    strcat(path, name);

    return hash_module_name(path);
}

//********************************************************/
//**  Small library for safe io to cacheable memory     **
//**  use smaller buffer then fopen so bigger could     **
//**  be loaded                                         **
//********************************************************/

static char* buf_load = 0;  // Also used for relocation & imports
static int   buf_size = 0;  // Current size, only re-allocate if larger buffer needed

// Allocate uncached memory buffer of given size
// Only allocate buffer if no buffer exists or new size is larger than existing buffer
// Returns 0 on error, or allocated size if no error
static int get_buffer(int size)
{
    size = (size + 3) & 0xFFFFFFFC; // round up to 4 byte boundary
    if (size > buf_size)
    {
        if (buf_load)
        {
            ufree(buf_load);
            buf_load = 0;
            buf_size = 0;
        }
        buf_load = umalloc(size);
        if (buf_load)
            buf_size = size;
    }

    return buf_size;
}

// Allocate default buffer (if required)
// Open named module file, return file handle (or -1 if error)
static int b_open(const char* name)
{
    if (!get_buffer(BUFFER_FOR_READ_SIZE))
    {
        return -1;
    }

    return open(name, O_RDONLY, 0777);
}

// Read 'len' bytes from file - uses uncached memory buffer
// Copy file contents to destination 'buf'
// Returns number of bytes read from file
int b_read(int fd, char* buf, int len)
{
    int loaded = 0, now = 1;

    while (now && loaded<len)
    {
        now = len - loaded;
        if (now > buf_size)
            now = buf_size;

        now = read(fd, buf_load, now);
        memcpy(buf+loaded, buf_load, now);
        loaded += now;
    }

    return loaded;
}

// Close module file if still open
void b_close(int fd)
{
    if (fd >= 0)
        close(fd);
}

//********************************************************/
//**       Auxilary module system functions             **
//********************************************************/

// Case insensitive comparison
// Returns 1 if strings are equal, 0 otherwise
static int namecmp(const char* s1, const char* s2)
{
    if ((s1 == 0) && (s2 == 0)) return 1;   // Both null --> equal
    if ((s1 == 0) || (s2 == 0)) return 0;   // One null (but not both) --> not equal
    while (*s1 && *s2)
    {
        if (tolower(*s1) != tolower(*s2)) return 0;
        s1++;
        s2++;
    }
    return ((*s1 == 0) && (*s2 == 0));
}

//-----------------------------------------------
// PURPOSE: Find loaded module by name hash
// RETURN: -1 if module not loaded yet, otherwise idx in modules[]
//-----------------------------------------------
static int module_find(unsigned int hash)
{
    int i;

    for (i=0; i<MAX_NUM_LOADED_MODULES; i++)
    {
        if (modules[i].hdr && (modules[i].hName == hash))
        {
            return i;
        }
    }
    return -1;
}

//-----------------------------------------------
// Display module load/unload error message on console
static void moduleload_error(const char* name, const char* text)
{
    extern volatile int chdk_started_flag;
    if (chdk_started_flag)
    {
        char buf[100];
        sprintf(buf, "Fail to load %s: %s", name, text);

        console_clear();
        console_add_line(buf);
        msleep(1000);
    }
}

//-----------------------------------------------
// Module relocation and linking to CHDK core

// Relocation of loaded module
// Relocation table is a list of int (4 byte) values, each value specifies the offset in the
// module of a pointer (4 bytes) to relocate. The offset is relative to the start of the module file.
// The initial values stored at each pointer are correct assuming the module was loaded at address 0.
// To relocate simply update the pointer with initial value + the actual load address of the module.
static int module_do_relocations(flat_hdr* flat, void* relocbuf, uint32_t reloc_count)
{
    int i;
    unsigned char* buf = (unsigned char*)flat;      // base address of module in memory
    uint32_t* rbuf = (uint32_t*)relocbuf;           // relocation array

    for (i=0; i < reloc_count; i++)
    {
        // Add initial value at relocated address to the base module address
        *(uint32_t*)(buf+rbuf[i]) += (uint32_t)buf;
    }

    return 1;
}

// Find function or variable address in array from hash id.
// Performs a binary search of the symbol_hash_table array looking for the 'importid' value
// Returns the function or variable address if found, 0 if not found
static const void* module_find_symbol_address(uint32_t importid)
{
    int min = 0, max = EXPORTLIST_COUNT-1;
    do
    {
        int mid = (min + max) >> 1;
        if (importid == symbol_hash_table[mid].hash)
            return symbol_hash_table[mid].address;
        else if (importid > symbol_hash_table[mid].hash)
            min = mid + 1;
        else
            max = mid - 1;
    } while (min <= max);
    return 0;
}

// Link module to CHDK core code.
// Functions and variables to link to are mapped via the symbol_hash_table array.
// The link information in the module comprises 'import_count' int values (4 bytes each)
// grouped into blocks. Each block is defined as:
//      - function / variable symbol hash
//      - N x int values, each value specifies the offset in the module to link
// The value of N is stored in the top 8 bits of the first value in list.
// Each location to link is assumed to be a pointer (4 bytes) into the CHDK core memory.
// To update each link location add the initial value stored to the link address found in the symbol table.
static int module_do_imports(flat_hdr* flat, void* relocbuf, uint32_t import_count)
{
    int i;
    unsigned char* buf = (unsigned char*)flat;  // base address of module in memory
    uint32_t* rbuf = (uint32_t*)relocbuf;       // link array

    for (i=0; i < import_count;)
    {
        // Find CHDK address of symbol via hash value, if not found return error
        int importaddress = (int)module_find_symbol_address(rbuf[i++]);
        if (importaddress == 0) return 0;

        // Get number of locations in module to link
        int cnt = rbuf[i] >> 24;

        for (; cnt>0; cnt--)
        {
            // Get offset into module (exclude count value)
            uint32_t offs = rbuf[i++] & 0x00FFFFFF;
            // Add initial value at location to symbol address
            *(uint32_t*)(buf+offs) += importaddress;
        }
    }  
    return 1;
}

//-----------------------------------------------
// Load relocation or link data from module file, call appropriate function to process data
// return: 0 if error, otherwise ok
static int module_do_action(int fd, flat_hdr* mod, uint32_t offset, uint32_t segment_size, int (*func)(flat_hdr*, void*, uint32_t))
{
    if (segment_size > 0)
    {
        if (lseek(fd, offset, SEEK_SET) == offset)
        {
            if (read(fd, buf_load, segment_size) == segment_size)
            {
                // relocate or link module
                return func(mod, (uint32_t*)buf_load, segment_size >> 2);
            }
        }
        return 0;
    }
    return 1;
}

//********************************************************/
//**           Main module system functions             **
//********************************************************/

//-----------------------------------------------
// Logging

// Append a line to the module log file if logging enabled
static void module_writeline(char *buf)
{
    if (conf.module_logging)
    {
        int fd = open("A/MODULES.LOG", O_WRONLY|O_CREAT|O_APPEND, 0777);
        if (fd >= 0)
        {
            lseek(fd, 0, SEEK_END);
            write(fd, buf, strlen(buf));
            close(fd);
        }
    }
}

// Write header line to the module file if logging enabled
// Once header written, it will not be written again until CHDK restarted.
static void module_log_hdr()
{
    static int hdr_logged = 0;

    if (conf.module_logging)
    {
        if (hdr_logged == 0)
        {
            hdr_logged = 1;

            time_t datetime;
            struct tm *ttm;
            char buf[100];

            datetime = time(NULL);
            ttm = localtime(&datetime);

            sprintf(buf, "Tick    ,Op,Address ,Name (%04d:%02d:%02d %02d:%02d:%02d)\n", ttm->tm_year+1900, ttm->tm_mon+1, ttm->tm_mday, ttm->tm_hour, ttm->tm_min, ttm->tm_sec);

            module_writeline(buf);
        }
    }
}

// Delete log file
void module_log_clear()
{
    remove("A/MODULES.LOG");
}

// Log message about a module being loaded
static void module_log_load(const char *name, void* adr)
{
    if (conf.module_logging)
    {
        char buf[100];
        sprintf(buf,"%8d,LD,%08x,%s\n",get_tick_count(),adr,name);

        module_log_hdr();
        module_writeline(buf);
    }
}

// Log message about a module being unloaded
static void module_log_unload(char *name)
{
    if (conf.module_logging)
    {
        char buf[100];
        sprintf(buf,"%8d,UN,        ,%s\n",get_tick_count(),name);

        module_log_hdr();
        module_writeline(buf);
    }
}

//-----------------------------------------------
// Bind/unbind loaded module to library pointer
static int bind_module(module_handler_t* hMod, void* module_lib)
{
    // If unloading module, reset library to unloaded default
    if (module_lib == 0)
        *hMod->lib = hMod->default_lib;
    else
        *hMod->lib = module_lib;

    return 0;
}

//-----------------------------------------------
// Unload module at given index in modules array
static void module_unload_idx(int idx)
{
    if ((idx >= 0) && (modules[idx].hdr != 0))
    {
        // Log unload
        module_log_unload(modules[idx].hMod->name);

        // Call module unload function
        if (modules[idx].hdr->_module_info->lib->unloader)
            modules[idx].hdr->_module_info->lib->unloader();

        // Unbind pointers to module (chdk core callback)
        bind_module(modules[idx].hMod, 0);

        // Free module memory, and mark module as inactive
        free(modules[idx].hdr);
        modules[idx].hdr = 0;
    }
}

// Unload module by name
void module_unload(const char* name)
{
    // Get full path to module file, and hash of path
    char path[60];
    unsigned int hash = get_module_path(path, name);

    // Find loaded module, and unload it
    module_unload_idx(module_find(hash));
}

//-----------------------------------------------
// Validate loaded module header and versions
// Returns 0 if all ok, otherwise returns error message
static char* validate(ModuleInfo *mod_info, _version_t ver)
{
    static char msg[50];

    if ((mod_info->magicnum != MODULEINFO_V1_MAGICNUM) || (mod_info->sizeof_struct != sizeof(ModuleInfo)))
        return "Malformed module info";

    if (mod_info->chdk_required_branch && (mod_info->chdk_required_branch != CURRENT_CHDK_BRANCH))
        return "require different CHDK branch";

    if (mod_info->chdk_required_architecture != OPT_ARCHITECTURE)
        return "wrong CHDK architecture";

    if (mod_info->chdk_required_ver > CHDK_BUILD_NUM)
    {
        sprintf(msg, "require CHDK%05d", mod_info->chdk_required_ver);
        return msg;
    }

    if (mod_info->chdk_required_platfid && (mod_info->chdk_required_platfid != conf.platformid))
    {
        sprintf(msg, "require platfid %d", mod_info->chdk_required_platfid);
        return msg;
    }

    if (!chk_api_version(mod_info->module_version, ver))
        return "incorrect module version";

    if (!chk_api_version((_version_t)CONF_VERSION, mod_info->conf_ver))
        return "incorrect CONF version";

    if (!chk_api_version((_version_t)CAM_SCREEN_VERSION, mod_info->cam_screen_ver))
        return "incorrect CAM SCREEN version";

    if (!chk_api_version((_version_t)CAM_SENSOR_VERSION, mod_info->cam_sensor_ver))
        return "incorrect CAM SENSOR version";

    if (!chk_api_version((_version_t)CAM_INFO_VERSION, mod_info->cam_info_ver))
        return "incorrect CAM INFO version";

    return 0;
}

// Allocate module memory and load file
// Returns 0 if all ok, otherwise returns error message
static char* load_module_file(int fd, const char* name, int size, int bss_size, flat_hdr** flat_buf)
{
    *flat_buf = (flat_hdr*)malloc(size+bss_size);
    if (!*flat_buf)
        return "malloc";

    module_log_load(name, *flat_buf);

    if (lseek(fd, 0, SEEK_SET) == 0)
    {
        if (b_read(fd, (char*)*flat_buf, size) == size)
        {
            memset((unsigned char*)(*flat_buf)+size, 0, bss_size);
            return 0;
        }
    }

    // Load failed, free memory
    free(*flat_buf);
    *flat_buf = 0;

    return "read";
}

// Relocate and link module
// Returns 0 if all ok, otherwise returns error message
static char* link_module(int fd, flat_hdr* flat_buf)
{
    // Make relocations
    int reloc_size = flat_buf->import_start - flat_buf->reloc_start;
    int import_size = flat_buf->import_size;

    // Get larger buffer size if needed
    int sz = (reloc_size > import_size) ? reloc_size : import_size;

    if (!get_buffer(sz))  // Re-allocate if needed
        return "malloc";

    if (!module_do_action(fd, flat_buf, flat_buf->reloc_start, reloc_size, module_do_relocations))
        return "reloc error";

    if (!module_do_action(fd, flat_buf, flat_buf->import_start, import_size, module_do_imports))
        return "link error";

    return 0;
}

// Attempt to load a module file.
// If file found and is a valid module, then load into memory, relocate and link to CHDK core
// Returns memory address of module if successful, 0 if failure.
flat_hdr* module_preload(const char *path, const char *name, _version_t ver)
{
    // Allocate buffer and open file
    int module_fd = b_open(path);
    if (module_fd <= 0)
    {
        moduleload_error(name, "open error");
        return 0;
    }

    // Read module header only to get size info
    flat_hdr flat;
    b_read(module_fd, (char*)&flat, sizeof(flat));  // TODO - compare loaded with requested size

    // Error message
    char *msg = 0;

    // Pointer to memory allocated to load module
    flat_hdr* flat_buf = 0;

    // Check version and magic number - make sure it is a CHDK module file
    if ((flat.rev == FLAT_VERSION) && (flat.magic == FLAT_MAGIC_NUMBER))
    {
        // Allocate module memory, and load module code
        msg = load_module_file(module_fd, name, flat.reloc_start, flat.bss_size, &flat_buf);
        if (msg == 0)
        {
            // Module info checks
            ModuleInfo *mod_info = flat_buf->_module_info = (ModuleInfo*)((unsigned int)flat_buf+flat_buf->_module_info_offset);

            // Validate version requirements
            msg = validate(mod_info, ver);
            if (msg == 0)
            {
                // Make relocations
                msg = link_module(module_fd, flat_buf);
            }
        }
    }
    else
        msg = "bad magicnum";

    // Close file
    b_close(module_fd);

    // If any error found, free module memory and display error
    if (msg)
    {
        if (flat_buf)
            free(flat_buf);
        moduleload_error(name, msg);
        return 0;
    }

    // TODO these could be changed to operate on affected address ranges only
    // after relocating but before attempting to execute loaded code
    // clean data cache to ensure code is in main memory
    dcache_clean_all();
    // then flush instruction cache to ensure no addresses containing new code are cached
    icache_flush_all();

    // Return module memory address
    return flat_buf;
}

// Load a module referenced by a 'module_handler_t' structure
// Returns index into modules array if successful (or module already loaded)
// otherwise returns -1
static int _module_load(module_handler_t* hMod)
{
    int idx;

    // Get full path to module file, and hash of path
    char path[60];
    unsigned int hash = get_module_path(path, hMod->name);

    // Check if module already loaded
    idx = module_find(hash);
    if (idx >= 0)
        return idx;

    // Reset lib (should not be needed, loader should only be called from 'default' lib)
    *hMod->lib = hMod->default_lib;

    // Simple lock to prevent multiple attempts to load modules simultaneously (in different tasks)
    // Not perfect; but should be sufficient
    static int isLoading = 0;
    while (isLoading != 0) msleep(10);
    isLoading = 1;

    // Find empty slot   
    for (idx=0; idx<MAX_NUM_LOADED_MODULES && modules[idx].hdr; idx++) ;

    // If no slot found return error
    if  (idx == MAX_NUM_LOADED_MODULES)
    {
        moduleload_error(hMod->name, "too many modules loaded");
        idx = -1;
    }
    else
    {
        // Load and relocate module (returns 0 if error)
        flat_hdr* mod = module_preload(path, hMod->name, hMod->version);

        if (mod != 0)
        {
            // Module is valid. Finalize binding
            modules[idx].hdr = mod;
            modules[idx].hName = hash;
            modules[idx].hMod = hMod;

            int bind_err = bind_module(hMod, mod->_module_info->lib);

            // Call module loader if required
            if (!bind_err && mod->_module_info->lib->loader)
            {
                bind_err = mod->_module_info->lib->loader();
            }

            // If any errors, unload module and display error message
            if (bind_err)
            {
                module_unload_idx(idx);
                moduleload_error(hMod->name, "loader error");
                idx = -1;
            }
        }
        else
        {
            // module did not load, return invalid index
            idx = -1;
        }
    }

    // Release lock
    isLoading = 0;

    return idx;
}

// Load a module referenced by a 'module_handler_t' structure
// Return: 0-fail, 1-ok
int module_load(module_handler_t* hMod)
{
    // Attempt to load module
    _module_load(hMod);

    // If load succeeded return success
    if (*hMod->lib && (*hMod->lib != hMod->default_lib))
    {
        return 1;
    }

    // If load failed reset library to unloaded default (should not be needed!)
    if (*hMod->lib == 0)
        *hMod->lib = hMod->default_lib;

    // Failure
    return 0;
}

//-----------------------------------------------
// Simple module support - allow module to be loaded and run by name.
// Module must implement the 'run' method
//-----------------------------------------------
// Number of simple modules that can be loaded at any one time
#define MAX_SIMPLE_MODULE   4

// Forward reference for default run methods - one for each simple module
static int default_run0();
static int default_run1();
static int default_run2();
static int default_run3();

// Default library handlers - one per simple module
static libsimple_sym default_librun[MAX_SIMPLE_MODULE] =
{
    { { 0, 0, 0, 0, default_run0 } },
    { { 0, 0, 0, 0, default_run1 } },
    { { 0, 0, 0, 0, default_run2 } },
    { { 0, 0, 0, 0, default_run3 } }
};
static libsimple_sym* librun[MAX_SIMPLE_MODULE] = { &default_librun[0], &default_librun[1], &default_librun[2], &default_librun[3] };

// Name of loaded module in each slot
// Each buffer needs to be long enough to hold full path to module (when called from file browser)
static char h_name[MAX_SIMPLE_MODULE][64];

// Handlers for simple modules - link to above implementation
static module_handler_t h_run[MAX_SIMPLE_MODULE] =
{
    { (base_interface_t**)&librun[0], &default_librun[0].base, ANY_VERSION, h_name[0] },
    { (base_interface_t**)&librun[1], &default_librun[1].base, ANY_VERSION, h_name[1] },
    { (base_interface_t**)&librun[2], &default_librun[2].base, ANY_VERSION, h_name[2] },
    { (base_interface_t**)&librun[3], &default_librun[3].base, ANY_VERSION, h_name[3] }
};

// Display error message if attempting to run a module with no 'run' method, or no space left for module
static void module_run_error(int err, char *name)
{
    char buf[100];
    sprintf(buf, lang_str(err), name);
    gui_mbox_init(LANG_ERROR, (int)buf, MBOX_BTN_OK|MBOX_TEXT_CENTER, NULL);
}

// Default run method
// If module loaded in selected slot call the 'run' method.
// If not 'run' method defined then display error
static int default_run(int n)
{
    if (module_load(&h_run[n]))
    {
        if ((*h_run[n].lib)->run)
        {
            return (*h_run[n].lib)->run();
        }
        else
        {
            // Error - module does not support 'simple' mode
            module_run_error(LANG_MODULE_NOT_SIMPLE, h_run[n].name);
            // Assumption - module will unload automatically via module_tick_unloader()
        }
    }

    return -1;
}

// Default run methods - one for each simple module
static int default_run0() { return default_run(0); }
static int default_run1() { return default_run(1); }
static int default_run2() { return default_run(2); }
static int default_run3() { return default_run(3); }

//-----------------------------------------------
// PURPOSE:      run simple module "name"
// RETURN VALUE: passed from module. -1 if something was failed
//-----------------------------------------------
int module_run(char* name)
{
    int i;
    for (i=0; i<MAX_SIMPLE_MODULE; i++)
    {
        // Check if module loaded (otherwise name not valid)
        if (*h_run[i].lib != h_run[i].default_lib)
        {
            if (namecmp(name, h_run[i].name))
            {
                // Already loaded
                return (*h_run[i].lib)->run();
            }
        }
    }
    for (i=0; i<MAX_SIMPLE_MODULE; i++)
    {
        // Look for empty slot
        if (*h_run[i].lib == h_run[i].default_lib)
        {
            // Found space - run module
            strcpy(h_run[i].name, name);
            return (*h_run[i].lib)->run();
        }
    }

    // Error - no space
    module_run_error(LANG_MODULE_NO_SPACE, name);

    return -1;
}

//-----------------------------------------------
// Warn modules when leaving <ALT>
//   1. Called when goto GUI_MODE_NONE
//   2. Tell all modules that we are leaving <ALT> mode
//-----------------------------------------------
void module_exit_alt()
{
    int idx;

    for (idx=MAX_NUM_LOADED_MODULES-1; idx>=0; idx--)
    {
        if (modules[idx].hdr && modules[idx].hdr->_module_info->lib->exit_alt)
        {
            // Tell module we are leaving <ALT>
            modules[idx].hdr->_module_info->lib->exit_alt();
        }
    }
}

//-----------------------------------------------
// Called on each tick to safe asynchronous unload module by its requests 
//-----------------------------------------------
void module_tick_unloader()
{
    int idx;

    for (idx=MAX_NUM_LOADED_MODULES-1; idx>=0; idx--)
    {
        if (modules[idx].hdr && modules[idx].hdr->_module_info->lib->can_unload)
        {
            // Ask module if it is safe to unload
            if (modules[idx].hdr->_module_info->lib->can_unload())
                module_unload_idx(idx);
        }
    }
}

//-----------------------------------------------
// Return address of module entry in modules array for given index
// return 0 if no valid module at given index
//-----------------------------------------------
module_entry* module_get_adr(unsigned int idx)
{
    if ((idx >= 0) && (idx < MAX_NUM_LOADED_MODULES))
        if (modules[idx].hdr)
            return &modules[idx];
    return 0;
}

//-----------------------------------------------
// Load module file and return ModuleInfo data
void get_module_info(const char *name, ModuleInfo *mi, char *modName, int modNameLen)
{
    memset(mi, 0, sizeof(ModuleInfo));
    if (modName)
        modName[0] = 0;     // Only used if module name stored in file (not a LANG string)

    // Get full path to module file, and hash of path
    char path[60];
    get_module_path(path, name);

    // open file
    int fd = open(path, O_RDONLY, 0777);
    if (fd < 0)
        return;

    // Read module header only to get size info
    flat_hdr flat;
    read(fd, (char*)&flat, sizeof(flat_hdr));

    // Check version and magic number - make sure it is a CHDK module file
    if ((flat.rev == FLAT_VERSION) && (flat.magic == FLAT_MAGIC_NUMBER))
    {
        lseek(fd, flat._module_info_offset, SEEK_SET);
        read(fd, mi, sizeof(ModuleInfo));

        if ((mi->moduleName >= 0) && modName)
        {
            // Load module name string
            lseek(fd, mi->moduleName, SEEK_SET);
            read(fd, modName, modNameLen-1);
            modName[modNameLen-1] = 0;
        }
    }

    close(fd);
}

//-----------------------------------------------
